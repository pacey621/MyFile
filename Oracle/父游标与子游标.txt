
解析的结果是将一个父游标和子游标保存到library cache中，将它们保存到sga，是为了重用它们，从而避免硬解析。

父游标的关键信息是sql文本；子游标的关键信息是执行计划和执行环境。

通过v$sqlarea查询父游标的信息；v$sql查询子游标的信息。

父游标由sql_id唯一确定；子游标由sql_id、child_number唯一确定。

父游标的关键信息是sql文本，因此多个sql只有在它们的文本完全一致的情况下才可以共享同一个父游标。

存在可以共享父游标而无法共享子游标的情形。


每个游标都是由library cache中的两个或多个对象所体现的，至少两个对象：
一个对象叫做父游标（parent cursor），包含游标的名称以及其他独立于提交用户的信息，从v$sqlarea视图里看到的都是有关父游标的信息；
另外一个或多个对象叫做子游标（child cursors），如果SQL文本相同，但是可能提交SQL语句的用户不同，或者用户提交的SQL语句所涉及到的对象为同名词等，都有可能生成不同的子游标。因为这些SQL语句的文本虽然完全一样，但是上下文环境却不一样，因此这样的SQL语句不是一个可执行的对象，必须细化为多个子游标后才能够执行。子游标含有执行计划或者PL/SQL对象的程序代码块等。

-----------------------------------------------------------------------------------------------

父游标：
在进行硬解析时产生，父游标里主要包含两种信息：SQL文本以及优化目标(optimizer goal)。
v$sqlarea中的每一行代表了一个parent cursor。
                
子游标：
当发生硬解析时，在产生父游标的同时，则跟随父游标会产生相应的子游标，此时V$SQL.CHILD_NUMBER的值为0。如果存在父游标，由于不同的运行环境，此时同样会产生新的子游标，新子游标的CHILD_NUMBER在已有子游标基础上以1为单位累计。
子游标包括游标所有相关信息，如具体的执行计划、绑定变量，OBJECT和权限，优化器设置等。


清空共享池：
SQL>ALTER SYSTEM FLUSH SHARED_POOL;