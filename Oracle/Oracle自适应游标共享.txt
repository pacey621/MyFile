
Oracle绑定变量窥探

Bind Peeking是Oracle 9i中引入的新特性，它的作用是在SQL语句硬解析的时候，查看一下当前SQL谓词的值，以便生成最佳的执行计划。

Bind Peeking只发生在硬解析的时候，即SQL被第一次执行的时候，之后的变量将不会再做peeking。

Bind peeking并不能最终解决不同谓词导致选择不同执行计划的问题，它只能让SQL第一次执行的时候，执行计划选择更加准确，并不能帮助OLAP系统解决绑定变量导致执行计划选择错误的问题。

对于绑定变量列中的特殊值或非均匀分布列上的绑定变量会造成非高效的执行计划被选择并执行。


----------------------------------------------------------------------------------------------

绑定变量可以为多条SQL语句共享单个游标，以减少解析SQL语句所花费的时间。然而，游标共享和SQL优化是两个相互冲突的目标。

绑定变量的引入减少了硬解析，每次都直接使用第一次绑定变量窥探产生的执行计划。但这带来了一个问题，就是当列数据倾斜时，该执行计划很可能并不合理，造成执行效率低下。


自适应游标共享Adaptive Cursor Sharing或扩展的游标共享(Extended Cursor Sharing)是Oracle 11g的新特性，主要用于解决以前版本中由于绑定变量窥探导致SQL语句无法获得最佳执行计划的缺陷。

自适应游标共享会使包含绑定变量的单个SQL语句拥有多个执行计划，所谓自适应是指执行计划会依据绑定变量的具体值而适配一个最适合该值的执行计划。


----------------------------------------------------------------------------------------------


自适应游标共享：主要用来改进具有绑定变量的sql语句的执行计划，这也导致了具有绑定变量的sql语句可能会生成多个子游标。


当某游标被设置为BIND_SENSITIVE(指该游标可能会因为绑定变量的不同取值而具有不同的效率表现，因此oracle会监视bind_sensitive的游标)；

当oracle发现bind_sensitive的游标确实会因为绑定变量的不同取值而表现出不同的效率时（如逻辑读的跳跃），oracle会记录该游标。在下一次调用该游标时，oracle根据绑定变量值生成新的游标，将新游标标记为BIND_AWARE,将就游标的共享标识置为NO,即旧游标将逐渐被丢弃并置换出内存。

当oracle再次执行该语句时，会根据绑定变量的取值来计算选择性（例如，通过直方图），如果计算出的选择性已经存在于以往子游标中，则调用子游标，否则创建新的子游标；

如果新的子游标和旧子游标的执行计划相同，oracle会将其合并，使用新的子游标，并逐步丢弃旧子游标。

注意：

bind_sensitive:绑定变量可能影响执行计划，需要oracle来监视

bind_aware:绑定变量会影响执行计划，oracle会根据不同的绑定变量选择或者生成新的执行计划。


当一个游标被标记为bind-aware后，只要绑定变量的值落入之前收集的绑定变量值与选择率的直方图内，优化器就会重用一个已经存在并且对该绑定变量来说最优的执行计划，如果绑定变量的值没有落入上述直方图内，则会进行硬解析。由此可见，自适应游标共享的好处是既减少了硬解析的次数，对于不同的绑定变量值来说又能找到一个合适它的执行计划。



自适应游标共享在SQL语句首次执行时(使用绑定变量)，进行窥探，并记录窥探结果，如果后续有相同的的SQL语句执行，则对窥探结果进行比较以判断是否需要生成新的执行计划。此即为绑定变量是否敏感。

绑定变量的可知性用于判断当前的游标是否为可扩展性游标共享，当不可知时，则游标被废弃。



-----------------------------------------------------------------------------------------------

自适应游标共享主要通过三个字段来体现，即is_bind_sensitive,is_bind_aware,is_shareable。
(注:此三个字段仅在Oracle 11g中存在)。
可以通过查询v$sql得到。

V$SQL：检查一个游标是否是 bind-sensitive 以及bind-aware的游标。

is_bind_sensitive(绑定是否敏感)
表示该子游标中是否使用了绑定变量要素，且采用bind peeking方法进行执行计划生成。如果执行计划依赖于窥探到的值，此处为Y，否则为N。
      
is_bind_aware(绑定是否可知)
表示该子游标是否使用了extended cursor sharing技术，是则为Y，否则为N。
如为N，则该游标将废弃，不再可用。
      
is_shareable(是否可共享)
表示该子游标可否被下次软解析是否可共享使用。可共享则为Y，否则为N，表示该子游标失去了共享价值，按LRU算法淘汰。






